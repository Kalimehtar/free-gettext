#lang racket/base
;; gettext superset implemented in Scheme
;;
;; Copyright (c) 2003-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;; Modifications for CHICKEN 4 by Thomas Chust (2010)
;; Modifications for Racket by Roman Klochkov (2019)

;; This is *not* gettext, nor does it use the C gettext library.
;;
;; This is a full gettext superset written in pure Scheme from reading
;; the gettext documentation - I have never looked at the gettext source
;; code, so this may be used under a more liberal BSD-style license as
;; above.
;;
;; This library includes various extensions, including the ability to
;; support multiple domains, locales and search paths; the ability to
;; read both .po and .mo files directly as message catalogs; and a more
;; Schemeish dispatch interface.
;;
;; The multiple domain interface is useful because it allows multiple
;; applications to share message catalogs while still extending their
;; own messages.  Many applications use many of the same messages, such
;; as those for menu names, and these messages can easily be leveraged
;; in Scheme as follows:
;;
;;   (textdomain '("myapp" "gimp"))  ; search 1st myapp, then gimp
;;   (gettext "/File/Close")         ; "Close" from gimp unless overridden
;;
;; Multiple locales can be useful while translations are still in
;; progress.  It is not fair to assume that English (or whatever the
;; native source uses) is the best alternative for a message that has
;; not yet been translated, so the locale may also be a list:
;;
;;   (textdomain "myapp" '("ru" "uk"))  ; search 1st Russian then Ukranian,
;;   (gettext "Hello, World!")          ; which are somewhat similar
;;
;; Note in both cases the domain and locale may be either a single
;; string (as in the C gettext) or a list of strings in order of
;; decreasing priority.  Also TEXTDOMAIN takes locale as an optional 2nd
;; parameter (to override the Unix environment variable), and in fact
;; the full parameter list is as follows:
;;
;;   (textdomain domain [locale] [dirs] [cdir] [cached?] [lookup-cached?])
;;
;; DOMAIN is a string or list of strings specifying the domain (name of
;; .mo or .po files) as in C gettext.
;;
;; LOCALE is a string or list of strings in the standard Unix format of
;; LANG[_REGION][.ENCODING]
;;
;; DIRS is the search path of directories which should hold the
;; LOCALE/CDIR/ directories which contain the actual message catalogs.
;; This is always appended with the system default, e.g.
;; "/usr/share/locale", and may also inherit from the GETTEXT_PATH
;; colon-delimited environment variable.
;;
;; CDIR is the catagory directory, defaulting to either the LC_CATEGORY
;; environment variable or the appropriate system default
;; (e.g. LC_MESSAGES).  You generally won't need this.
;;
;; CACHED? means to cache individual messages, and defaults to #t.
;;
;; LOOKUP-CACHED? means to cache the lookup dispatch generated by these
;; parameters, and defaults to #t.
;;
;; TEXTDOMAIN just passes these parameters to the internal MAKE-GETTEXT,
;; and binds the result to the global dispatch used by GETTEXT.  You may
;; build these closures manually for convenience in using multiple
;; separate domains or locales at once (useful for server environments):
;;
;;  (define my-gettext (make-gettext "myapp"))
;;  (define _ (my-gettext 'getter))
;;  (_"Hello, World!")

(require srfi/2 racket/function racket/sequence racket/contract
         racket/list racket/string racket/port racket/bytes racket/match)

(define gettext?
  (->i ([action (or/c 'getter 'ngetter 'pgetter 'setter 'get 'pget 'npget 'nget 'set!
                      'locale 'domain 'dirs 'files 'use-cache 'clear)])
       #:rest [rest (action)
                    (case action
                      [(getter ngetter pgetter npgetter setter locale domain dirs files clear) null]
                      [(get) (list/c string?)]
                      [(pget) (list/c string? string?)]
                      [(nget) (list/c string? string? number?)]
                      [(npget) (list/c string? string? string? number?)]
                      [(set!) (list/c string? string?)]
                      [(use-cache) (list/c boolean?)])]
       [result (action)
               (case action
                 [(getter) (string? . -> . string?)]
                 [(pgetter) (string? string? . -> . string?)]
                 [(ngetter) (string? string? number? . -> . string?)]
                 [(npgetter) (string? string? string? number? . -> . string?)]
                 [(setter) (string? string? . -> . void?)]
                 [(locale) (listof string?)]
                 [(domain) (listof string?)]
                 [(dirs) (listof path-string?)]
                 [(files) (listof gfile?)]
                 [(clear use-cache set!) void?]
                 [(get nget pget) string?])]))

(provide/contract
 ;; standard gettext interface
 [gettext (string? . -> . string?)]
 [pgettext (string? string? . -> . string?)]
 [textdomain (->i
              ()
              ([name (or/c string? (listof string?))]
               #:locale [locale (or/c #f string? (listof string?))]
               #:dirs [dirs (or/c #f path-string? (listof path-string?))]
               #:cdir [cdir (or/c #f string?)]
               #:cached? [cached? boolean?]
               #:lookup-cached? [lookup-cached? boolean?])                            
              [result (name) (if (unsupplied-arg? name) string? gettext?)])]
 [ngettext (string? string? number? . -> . string?)]
 [npgettext (string? string? string? number? . -> . string?)]
 [dgettext (string? string? . -> . string?)]
 [dcgettext (string? string? string? . -> . string?)]
 [dngettext (string? string? string? number? . -> . string?)]
 [dcngettext (string? string? string? number? string? . -> . string?)]
 [bindtextdomain (string? string? . -> . void?)]
 [make-gettext (->* ((or/c string? (listof string?)))
                    (#:locale (or/c #f string? (listof string?))
                     #:dirs (or/c #f path-string? (listof path-string?))
                     #:cdir (or/c #f string?)
                     #:cached? boolean?
                     #:lookup-cached? boolean?)
                    gettext?)])

(define null-str (string #\nul))

(define (after-prefix prefix s)
  (define s-length (bytes-length s))
  (define prefix-length (bytes-length prefix))
  (cond
    [(< s-length prefix-length) #f]
    [else
     (and
      (for/and ([i (in-range prefix-length)])
        (= (bytes-ref s i) (bytes-ref prefix i)))
      (subbytes s prefix-length))]))

(define (bytes-trim s)
  (define s-length (bytes-length s))
  (define (isspace? s i) (memv (bytes-ref s i) '(9 32)))
  (define start (for/first ([i (in-range s-length)]
                            #:unless (isspace? s i))
                  i))
  (define end (for/first ([i (in-range s-length)]
                          #:unless (isspace? s (- s-length i 1)))
                (- s-length i)))
  (subbytes s start end))
  
(define (index s c [x 0])
  (for/first ([i (in-naturals)]
              [ci (sequence-tail s x)]
              #:when (eqv? ci c))
    (+ x i)))

(define (bytes-split-at s pos)
  (if pos
      (values (subbytes s 0 pos) (subbytes s (add1 pos)))
      (values #f s)))

(define (cartesian-product lol)
  (match lol
    [(list-rest l r)
     (define rest (cartesian-product r))
     (append-map
       (λ (x) (map (λ (sub-prod) (cons x sub-prod)) rest))
       l)]
    [else (list null)]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; mime utils (from hato)

(define (rfc822-read-headers in)
  (let more ([line (read-line in)])
    (cond
     [(or (eof-object? line) (string=? "" line))
      null]
     [(let ([cont (peek-char in)])
	(and (not (memv cont `(#\return #\newline ,eof)))
             (char-whitespace? cont)))
      (more (string-append line (read-line in)))]
     [(match line
        [(pregexp #px"(.*?)\\s*:\\s*(.*)" (list _ l r))
         (cons (cons (string-downcase (string-trim l)) r)
               (rfc822-read-headers in))]
        [else #f])]
     [else (rfc822-read-headers in)])))

(define (mime-split-name+value s)
  (define i (index s #\=))
  (if i
      (cons (string-downcase (string-trim (substring s 0 i)))
            (cond
              [(= i (string-length s)) ""]
              [(eqv? #\" (string-ref s (+ i 1)))
               (substring s (+ i 2) (- (string-length s) 2))]
              [else (substring s (+ i 1))]))
      (cons (string-downcase (string-trim s)) #f)))

(define (mime-parse-content-type str)
  (map mime-split-name+value (string-split str ";")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; binary I/O utils (from SRFI-56)

(define (read-binary-uint32-le [in (current-input-port)])
  (define b1 (read-byte in))
  (define b2 (read-byte in))
  (define b3 (read-byte in))
  (define b4 (read-byte in))
  (if (eof-object? b4)
      b4
      (+ (arithmetic-shift b4 24)
         (arithmetic-shift b3 16)
         (arithmetic-shift b2 8)
         b1)))

(define (read-binary-uint32-be [in (current-input-port)])
  (define b1 (read-byte in))
  (define b2 (read-byte in))
  (define b3 (read-byte in))
  (define b4 (read-byte in))
  (if (eof-object? b4)
      b4
      (+ (arithmetic-shift b1 24)
         (arithmetic-shift b2 16)
         (arithmetic-shift b3 8)
         b4)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Customize this to the appropriate value for your system:

(define message-path (find-library-collection-paths))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; store meta info for gettext files

(struct gfile (filename locale coder properties type plural-index) #:transparent)

(define (build-coder x)
  (define ((build coder) str)
    (and str
         (call-with-values (λ () (bytes-convert coder str))
                           (λ res (car res)))))
  (cons
   (build (bytes-open-converter "UTF-8" (cdr x)))
   (build (bytes-open-converter (cdr x) "UTF-8"))))

(define (make-gettext-file filename locale)
  (define file-type (if (string-suffix? (path->string filename) ".mo") 'mo 'po))
  (define properties
    (call-with-input-string (or (lookup-message filename "" #f) "") rfc822-read-headers))
  (define coder
    (or (and-let* ([property (assoc "content-type" properties)]
                   [charset (assoc "charset" (mime-parse-content-type (cdr property)))])
          (build-coder charset))
        (cons identity identity)))
  (define plural-index
    (or (and-let* ([property (assoc "plural-forms" properties)]
                   [content-type (assoc "plural" (mime-parse-content-type (cdr property)))])
          (C->Scheme (cdr content-type)))
        (const 0)))
  (gfile filename locale coder properties file-type plural-index))

;; take a list or a single argument which is interpretted as a one
;; element list
(define (listify arg) (if (or (pair? arg) (null? arg)) arg (list arg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; the default gettext lookup

(define domain-message-paths (make-hash))

(define default-gettext-lookup (make-parameter (λ _ "")))

(define (gettext msgid)
  ((default-gettext-lookup) 'get msgid))
(define (pgettext context msgid)
  ((default-gettext-lookup) 'pget context msgid))
(define (dgettext domain msgid)
  ((make-gettext domain) 'get msgid))
(define (dcgettext domain msgid category)
  ((make-gettext domain #:cdir category) 'get msgid))
(define (dpgettext domain context msgid)
  ((make-gettext domain) 'pget msgid))
(define (dcpgettext domain context msgid category)
  ((make-gettext domain #:cdir category) 'pget msgid))

;; plural forms
(define (ngettext msg msg2 n)
  ((default-gettext-lookup) 'nget msg msg2 n))
(define (dngettext domain msg msg2 n)
  ((make-gettext domain) 'nget msg msg2 n))
(define (dcngettext domain msgid msg msg2 n category)
  ((make-gettext domain #:cdir category) 'nget msg msg2 n))
(define (npgettext context msg msg2 n)
  ((default-gettext-lookup) 'npget context msg msg2 n))

;; bind the default domain
(define textdomain
  (procedure-reduce-keyword-arity
   (make-keyword-procedure
    (λ (kws kw-args . rest)
      (cond
        [(null? rest)
         (unless (null? kws) 
           (raise-arguments-error 'textdomain
                                  "no keyword allowed if there is no domain name argument"
                                  "keywords" kws))
         ((default-gettext-lookup) 'domain)]
        [else
         (define accessor (keyword-apply make-gettext kws kw-args rest))
         (default-gettext-lookup accessor)
         accessor])))
   '(0 1) null '(#:cached? #:cdir #:dirs #:locale #:lookup-cached?)))

(define (bindtextdomain domain dirs)
  (hash-set! domain-message-paths domain (listify dirs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The gettext .po parser.
;;   We sequentially scan all the .po msgstr entries until the one
;;   matching the msg string is found.  This is slow but only meant
;;   for development, so that you can quickly test your message
;;   files without compiling them to .mo files.

(define (lookup-po-message file msg-in msg2)
  (define qbyte (char->integer #\"))
  (define-values (context msg) (bytes-split-at msg-in (index msg-in 4)))
  (define current-context #f)
  (define (chop-quotes line)
    (define len (bytes-length line))
    (define len-1 (sub1 len))
    (and (>= len 2)
         (= qbyte (bytes-ref line 0))
         (= qbyte (bytes-ref line len-1))
         (subbytes line 1 len-1)))

  (define (read-str default)
    (bytes-append*
     (chop-quotes default)
     (sequence->list
      (in-producer (λ () (and (eqv? (peek-byte) qbyte)
                              (chop-quotes (bytes-trim (read-bytes-line)))))
                   #f))))

  (define bbyte (char->integer #\]))
  (define 0byte (char->integer #\0))
  (define mbyte (char->integer #\m))
  (define (read-plural-line line)
    (and line
         (= (bytes-ref line 1) bbyte)
         (cons (- (bytes-ref line 0) 0byte)
               (read-str (bytes-trim (subbytes line 2))))))
  
  (define (read-plural default)
    (list* default
           (sequence->list
            (in-producer (λ () (and (eqv? (peek-byte) mbyte)
                                    (read-plural-line (after-prefix #"msgstr[" (read-bytes-line)))))
                         #f))))

  ;; read from the file if it exists
  (with-input-from-file file
    (λ ()
      (let search ([line (read-bytes-line)] [current-context #f])
        (cond
          [(eof-object? line) #f]
          [(after-prefix #"msgctxt " line)
           =>
           (λ (tail)
             (define current-context (read-str tail))
             (search (read-bytes-line) current-context))]
          [(after-prefix #"msgid " line)
           =>
           (λ (tail)
             (if (and (bytes=? (read-str tail) msg) (equal? current-context context))
                 (let lp ([line (read-bytes-line)])
                   (cond [(eof-object? line) #f]
                         [(after-prefix #"msgid_plural " line) => (compose read-plural read-str)]
                         [(after-prefix #"msgstr " line) => read-str]
                         [else (lp (read-bytes-line))]))
                 (search (read-bytes-line) #f)))]
          [else (search (read-bytes-line) current-context)])))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The gettext binary .mo file parser.
;;   The format is well described in the GNU gettext documentation.
;;   Essentially it's an index of source strings with offsets to their
;;   translation string, and we binary search the index.

(define (lookup-mo-message file msg msg2)
  (with-input-from-file file
    (λ ()
      (define (search read-int)
        (define key (if msg2 (bytes-append msg (bytes 0) msg2) msg))
        (define format (read-int))
        (define count (read-int))
        (define src-offset (read-int))
        (define trans-offset (read-int))
        (define hash-size (read-int))
        (define hash-offset (read-int))
        (define diff (- trans-offset src-offset))
        (define end (+ src-offset (* (- count 1) 8)))
        (define (string-at pos)
          (file-position (current-input-port) pos)
          (define len (read-int))
          (define off (read-int))
          (file-position (current-input-port) off)
          (read-bytes len))
        (cond ;; check endpoints
          [(bytes=? key (string-at src-offset))
           (string-at (+ src-offset diff))]
          [(and (> end src-offset) (bytes=? key (string-at end)))
           (string-at (+ end diff))]
          [else ;; binary search
           (let loop ([lo 0] [hi (- count 1)])
             (and (< lo hi)
                  (let* ([mid (+ lo (quotient (- hi lo) 2))]
                         [pos (+ src-offset (* mid 8))]
                         [str (string-at pos)])
                    (cond
                      [(bytes<? key str)
                       (if (>= mid hi) #f (loop lo mid))]
                      [(bytes>? key str)
                       (if (<= mid lo) #f (loop mid hi))]
                      [else (string-at (+ pos diff))]))))]))
      (search
       (match (list (read-byte) (read-byte) (read-byte) (read-byte))
         ['(#xde #x12 #x04 #x95) read-binary-uint32-le]
         ['(#x95 #x04 #x12 #xde) read-binary-uint32-be])))))

(define (lookup-message gfile msg msg2)
  (define %msg (string->bytes/utf-8 msg))
  (define %msg2 (cond [msg2 => string->bytes/utf-8] [else #f]))
  (define ((to-string decoder) str)
    (define (convert s)
      (read (open-input-string (string-append "\"" (bytes->string/utf-8 (decoder s)) "\""))))
    (cond
      [(list? str)
       (map (to-string decoder) str)]
      [(pair? str)
       (cons (car str) (convert (cdr str)))]
      [str => convert]
      [else #f]))
  (cond
    [(gfile? gfile)
     (define coder (gfile-coder gfile))
     (define encoder (car coder))
     (define decoder (cdr coder))
     ((to-string decoder)
      ((if (eq? (gfile-type gfile) 'mo) lookup-mo-message lookup-po-message)
       (gfile-filename gfile)
       (encoder %msg)
       (encoder %msg2)))]
    [else
     ((to-string identity)
      ((if (string-suffix? (path->string gfile) ".mo") lookup-mo-message lookup-po-message)
       gfile %msg %msg2))]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; the subset C parser for ngettext plural forms

(define (C->Scheme str)
  (define (read-number c)
    (let loop ((ls (list c)))
      (let ((c2 (peek-char)))
        (cond ((and (not (eof-object? c2)) (char-numeric? c2))
               (read-char) (loop (cons c2 ls)))
              (else (string->number (list->string (reverse ls))))))))
  (define (read-comment)
    (read-char)
    (let loop ((c (read-char)))
      (if (eof-object? c)
          c ;; maybe signal error
          (if (eqv? c #\*)
              (let ((c2 (read-char)))
                (if (eqv? c2 #\/) #f (loop c2)))
              (loop (read-char))))))
  (define (next-token)
    (let ((c (read-char)))
      (if (eof-object? c)
          c
          (case c
            ((#\() 'open)
            ((#\)) 'close)
            ((#\/) (if (eqv? (peek-char) #\*) (read-comment) '/))
            ((#\- #\+ #\* #\% #\? #\:)
             (string->symbol (string c)))
            ((#\&) (if (eqv? (peek-char) c) (begin (read-char) 'and) 'logand))
            ((#\|) (if (eqv? (peek-char) c) (begin (read-char) 'or) 'logior))
            ((#\! #\> #\<)
             (cond ((eqv? (peek-char) #\=)
                    (read-char) (string->symbol (string c #\=)))
                   (else (string->symbol (string c)))))
            ((#\=)
             (cond ((eqv? (peek-char) #\=) (read-char) '==)
                   (else (error "invalid assignment in C code") #f)))
            ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
             (read-number c))
            ((#\n) 'n)
            ((#\space #\newline) (next-token))
            (else (error "invalid character in C code: ~S" c) #f)))))
  (define (C-parse str)
    (define (precedence x) ;; lower value is higher precedence
      (case x
        ((**) 10)           ((&) 70)
        ((! ~) 20)          ((^ logand logior) 80)
        ((* / %) 30)        ((and) 90)
        ((+ -) 40)          ((or) 100)
        ((< > <= >=) 50)    ((?) 110)
        ((== != <=>) 60)    (else 120)))
    (define (parse1)
      (let ((x (next-token)))
        (cond ((not x) (parse1))
              ((eof-object? x) 'eof)
              ((eq? x 'open) (parse-until 'close))
              ((memq x '(! ~)) `(,x ,(parse1)))
              (else x))))
    (define (parse-until end)
      (define (group op left right)
        (cond
         ((or (eq? right end) (eq? right 'eof))
          (error "expected 2nd argument to" op)
          `(op ,left))
         ((eq? op 'and)
          `(if (zero? ,left) 0 ,right))
         ((eq? op 'or)
          `(if (zero? ,left) ,right 1))
         (else
          `(,op ,left ,right))))
      (define (join x stack)
        (if (null? stack)
            x
            (join (group (car stack) (cadr stack) x) (cddr stack))))
      (let ((init (parse1)))
        (if (equal? init end)
            '()
            (let parse ((left init) (op (parse1)) (stack '()))
              (cond
               ((eq? op end) (join left stack))
               ((eq? op 'eof)
                (error "unexpected #<eof>")
                (join left stack))
               ((eq? op '?) ;; trinary ? : (right-assoc)
                (let* ((pass (parse-until ':))
                       (fail (parse1))
                       (op2 (parse1)))
                  (cond
                   ((or (eq? op2 end) (eq? op2 'eof))
                    `(if (zero? ,left) ,fail ,pass))
                   ((< (precedence op) (precedence op2))
                    (parse `(if (zero? ,left) ,fail ,pass) op2 stack))
                   (else
                    (join `(if (zero? ,left) ,(parse fail op2 '()) ,pass)
                          stack)))))
               (else ;; assume a (left-assoc) binary operator
                (let* ((right (parse1))
                       (op2 (parse1)))
                  (cond
                   ((or (eq? op2 end) (eq? op2 'eof))
                    (join (group op left right) stack))
                   ((<= (precedence op) (precedence op2))
                    ;; op2 has less than or equal precedence, group
                    (let loop2 ((x (group op left right)) (s stack))
                      (if (and (pair? s)
                               (< (precedence (car s)) (precedence op2)))
                          (loop2 (group (car s) (cadr s) x) (cddr s))
                          (parse x op2 s))))
                   (else
                    ;; op2 has higher precedence, push on the stack
                    (parse right op2 (cons op (cons left stack))))))))))))
    (with-input-from-string str
      (lambda () (parse-until 'eof))))
  (define (map-C-names x)
    (cond
     ((symbol? x)
      (case x
        ((/) 'quotient) ((%) 'modulo) ((**) 'expt)
        ((~) 'lognot)   ((^) 'logxor) ((<<) 'arithmetic-shift)
        ;; C conflates booleans with integers
        ((!) '(lambda (a) (if (zero? a) 1 0)))
        ((>>) '(lambda (a b) (arithmetic-shift a (- b))))
        ((==) '(lambda (a b) (if (eqv? a b) 1 0)))
        ((!=) '(lambda (a b) (if (eqv? a b) 0 1)))
        ((>) '(lambda (a b)  (if (> a b) 1 0)))
        ((<) '(lambda (a b)  (if (< a b) 1 0)))
        ((>=) '(lambda (a b) (if (>= a b) 1 0)))
        ((<=) '(lambda (a b) (if (<= a b) 1 0)))
        (else x)))
     ((pair? x)
      (cons (map-C-names (car x)) (map-C-names (cdr x))))
     (else x)))
  (let ((body (map-C-names (C-parse str))))
    ;; could build from chained closures w/o using eval but this is
    ;; faster at runtime
    (eval `(lambda (n) ,body) (make-base-namespace))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; internal routines for building/caching files and lookups

(define (split-langs lang)
  (define (split-at ch)
    (cond [(index lang ch)
           => (lambda (i) (list (substring lang 0 i)))]
          [else null]))
  (cons lang (append (split-at #\.) (split-at #\_))))

(define (file-read-access? path)
  (and (file-exists? path) (memq 'read (file-or-directory-permissions path))))

(define (make-gettext-internal domain locale dirs cdir cached?)

  (define (make-cache) (make-hash))

  (define (make-file-list)
    (define suffixes '(".mo" ".po"))
    (reverse
     (foldl
      (lambda (x res)
        (match x
          [(list x1 x2 x3 x4)
           (define path (build-path x3 x1 cdir (string-append x2 x4)))
           (if (file-read-access? path)
               (cons (make-gettext-file path x1) res)
               res)]))
      null
      (cartesian-product (list (append-map split-langs locale)
                               domain
                               dirs
                               suffixes)))))

  (define files (make-file-list))
  (define cache (make-cache))

  (define (search msg [msg2 #f] [n #f])
    (if (and cached? (hash-has-key? cache msg))
        (hash-ref cache msg #f)
        (let ((split? (number? n)))
          (for/or ([gf files])
            (and-let* ((x0 (lookup-message gf msg msg2))
                       (x (if (and split? (eq? (gfile-type gf) 'mo))
                              (cons (or msg2 msg)
                                    (let ((l (string-split x0 null-str)))
                                      (map cons (range (length l)) l)))
                              x0))
                       (res (cons x gf)))
              (when cached? (hash-set! cache msg res))
              res)))))

  (define (get msg) (pget #f msg))

  (define (pget ctxt msg)
    (match (search (if ctxt (string-append ctxt (string #\u0004) msg) msg))
      [(cons (cons trans _) _) trans]
      [(cons trans _) trans]
      [else msg]))

  (define (npget ctxt msg msg2 n)
    (match (search (if ctxt (string-append ctxt (string #\u0004) msg) msg) msg2 n)
      [(cons (list-rest trans plurals) gfile)
       (cond
         [(assv ((gfile-plural-index gfile) (or n 1)) plurals) => cdr]
         [else trans])]
      [else (if (or (eqv? n 1) (not msg2)) msg msg2)]))

  (define (nget msg msg2 n) (npget #f msg msg2 n))
    
  (define (set msg val) (hash-set! cache msg val))

  (define (reset!)
    (set! files (make-file-list))
    (set! cache (make-cache)))

  ;; return the dispatcher
  (lambda (dispatch . args)
    (case dispatch
      ((searcher) search)
      ((getter) get)
      ((ngetter) nget)
      ((npgetter) npget)
      ((pgetter) pget)
      ((setter) set)
      ((search) (apply search args))
      ((get) (apply get args))
      ((pget) (apply pget args))
      ((nget) (apply nget args))
      ((npget) (apply npget args))
      ((set!) (apply set args))
      ((locale) locale)
      ((domain) domain)
      ((dirs) dirs)
      ((files) files)
      ((set-locale!) (set! locale (listify (car args))) (reset!))
      ((set-domain!) (set! domain (listify (car args))) (reset!))
      ((set-dirs!) (set! dirs (listify (car args))) (reset!))
      ((use-cache) (set! cached? (car args)))
      ((clear) (set! cache (make-cache))))))

;; cache the lookups and provide a more friendly interface.  should this
;; take keyword arguments?
;; (make-gettext domain locale dirs cdir gettext-cached? lookup-cached?)
(define gettext-lookup-cache (make-hash))
(define (make-gettext domain0
                      #:locale [locale0 #f]
                      #:dirs [dirs0 #f]
                      #:cdir [cdir0 #f]
                      #:cached? [gettext-cached? #t]
                      #:lookup-cached? [lookup-cached? #t])
  (define domain (listify domain0))
  (define locale (listify (or locale0 (getenv "LANG") (getenv "LC_ALL") "C")))
  (define dirs1 (listify
                 (or dirs0 (cond [(getenv "GETTEXT_PATH")
                                  => (λ (x) string-split x ":")]
                                 [else null]))))
  ;; prepend default dirs based on domain
  (define dirs (append (hash-ref domain-message-paths domain message-path) dirs1))
  (define cdir (or cdir0 (getenv "LC_CATEGORY") "LC_MESSAGES"))
          ;; optionally lookup from cache
  (if lookup-cached?
      (hash-ref! gettext-lookup-cache
                 (list domain locale dirs cdir gettext-cached?)
                 (λ () (make-gettext-internal domain locale dirs cdir gettext-cached?)))
      (make-gettext-internal domain locale dirs cdir gettext-cached?)))

(module+ test
  (require rackunit)
  (let* ([mo-gettext (make-gettext "motest" #:locale "ja" #:dirs ".")]
         [ngetter (mo-gettext 'ngetter)]
         [getter (mo-gettext 'getter)])
    (check-equal? (ngetter "He was stabbed with ~A knife." "He was stabbed with ~A knives." 2)
                  "彼は~A包丁で刺された。")
    (check-equal? (ngetter "He was stabbed with ~A knife." "He was stabbed with ~A knives." 1)
                  "彼は~A包丁で刺された。")
    (check-equal? (getter "Help|Shrink") "Emacsの精神医学者"))
  (let* ([ja-gettext (make-gettext "test" #:locale "ja" #:dirs ".")]
         [ngetter (ja-gettext 'ngetter)]
         [getter (ja-gettext 'getter)])
    (check-equal? (ngetter "He was stabbed with ~A knife." "He was stabbed with ~A knives." 2)
                  "彼は~A包丁で刺された。")
    (check-equal? (ngetter "He was stabbed with ~A knife." "He was stabbed with ~A knives." 1)
                  "彼は~A包丁で刺された。")
    (check-equal? (getter  "Help|Shrink") "Emacsの精神医学者"))
  (let* ([ru-gettext (make-gettext "test" #:locale "ru" #:dirs ".")]
         [ngetter (ru-gettext 'ngetter)]
         [pgetter (ru-gettext 'pgetter)])
    (check-equal? (ngetter "%d user." "%d users." 1)
                  "%d пользователь.")
    (check-equal? (ngetter "%d user." "%d users." 2)
                  "%d пользователя.")
    (check-equal? (ngetter "%d user." "%d users." 5)
                  "%d пользователей.")
    (check-equal? (pgetter "First letter in 'Scope'" "S")
                  "О")
    (check-equal? (pgetter "South" "S")
                  "Ю")))